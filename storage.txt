document.addEventListener("DOMContentLoaded", () => {
    // Helper function for POST request
    async function sendDataToServer(data) {
        try {
            const response = await fetch("http://localhost:3000/allocate", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(data),
            });

            if (response.ok) {
                const result = await response.json();
                console.log("Server response:", result);
                alert("Data successfully sent to the server!");
            } else {
                const error = await response.json();
                console.error("Server error:", error);
                alert("Error occurred while sending data to the server.");
            }
        } catch (err) {
            console.error("Network error:", err);
            alert("Failed to connect to the server.");
        }
    }

    // Helper function for GET request
    // ! fetching timetable for section
    async function fetchDataFromServer(sectionMap) {
        console.log("I am in the method");
        const sectionId = document.getElementById("sectionId").value; // Get section ID from input
        const timetableContainer = document.getElementById("timetableContainer");

        timetableContainer.innerHTML = ""; // Clear any previous timetable
        console.log("Fetching timetable for section:", sectionId);
        console.log("in get", sectionMap);

        try {
            const response = await fetch(`http://localhost:3000/tt/${sectionId}`); // Fetch timetable for the entered section ID

            if (!response.ok) {
                const error = await response.json();
                timetableContainer.innerHTML = `<p style="color: red;">${error.message}</p>`;

                // ✅ REMOVE from localStorage and sectionMap if section not found
                if (response.status === 404) {
                    console.warn(`Section '${sectionId}' not found. Removing from localStorage.`);
                    sectionMap.delete(sectionId); // Remove from sectionMap

                    // Remove from localStorage
                    let stored = localStorage.getItem("sectionMap");
                    if (stored) {
                        const parsed = JSON.parse(stored);
                        const updated = parsed.filter(([id]) => id !== sectionId);
                        localStorage.setItem("sectionMap", JSON.stringify(updated));
                    }
                }
                return;
            }

            const { timetable, allocationMap } = await response.json();
            console.log("tt is ", timetable);

            // let timetable = jsonResponse.timetable;
            console.log("Timetable data type:", Array.isArray(timetable)); // Should return true if it's an array
            //console.log("Timetable:", timetable);
            timetable.forEach((row, index) => {
                console.log(`Row ${index}:`, row);
            });

            console.log("tt is ", timetable);

            if (!timetable || timetable.length === 0) {
                timetableContainer.innerHTML = `<p>No timetable found for section ID: ${sectionId}</p>`;
                return;
            }

            const table = document.createElement("table");
            const headerRow = document.createElement("tr");

            const days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"]; // Days of the week

            // Create the first column header for the days of the week
            const dayHeader = document.createElement("th");
            dayHeader.textContent = "Day/Period";
            headerRow.appendChild(dayHeader);

            // Create period headers
            const periods = [
                "9:00-10:00",
                "10:00-11:00",
                "11:10-12:10",
                "12:55-1:55",
                "1:55-2:55",
                "2:55-3:45",
            ];
            periods.forEach((period) => {
                const th = document.createElement("th");
                th.textContent = period;
                headerRow.appendChild(th);
            });

            table.appendChild(headerRow);

            // Add rows from the timetable
            timetable.forEach((row, index) => {
                const tableRow = document.createElement("tr");

                // Add day of the week (Monday to Friday)
                const dayCell = document.createElement("td");
                dayCell.textContent = days[index] || ""; // Add the day (e.g., Monday, Tuesday...)
                tableRow.appendChild(dayCell);
                //console.log(sectionMap)
                row.forEach((cell) => {
                    const td = document.createElement("td");
                    const sid = sectionMap.get(sectionId);
                    cell = cell.split(',')[0];
                    console.log(cell);
                    console.log(sid);
                    console.log(sid.has(cell));
                    // Get the faculty ID assigned to this cell
                    if (sid && sid.has(cell)) {
                        console.log("inner cell ", cell)
                        console.log(sid.get(cell));
                        const [subjectId, isLab] = sid.get(cell);
                        console.log("sub id..", subjectId.subjectId, "type of..", typeof (subjectId), "cell..", sid.get(cell));
                        td.textContent = subjectId.subjectId; // Display subject ID
                    } else {
                        td.textContent = "."; // Empty cell
                    }


                    tableRow.appendChild(td);
                });

                table.appendChild(tableRow);
            });

            timetableContainer.appendChild(table); // Append the table to the container
        } catch (error) {
            console.error("Error fetching timetable:", error);
            timetableContainer.innerHTML = `<p style="color: red;">An error occurred. Please try again later.</p>`;
        }
    }

    //! fetching timtebale for the individual faculty
    async function fetchTimetable() {
        const facultyId = document.getElementById("subIdInput").value.trim();
        if (!facultyId) {
            alert("Please enter a Subject ID.");
            return;
        }

        try {
            const response = await fetch(`http://localhost:3000/ft/${facultyId}`);

            if (!response.ok) {
                throw new Error(`Server error: ${response.status}`);
            }

            const data = await response.json();
            console.log(data)
            if (
                !data ||
                !data ||
                data.length === 0
            ) {
                alert("No timetable found for this subject.");
                return;
            }
            console.log(data.facultyTimetable);
            displayTimetable(data.facultyTimetable);
        } catch (error) {
            alert("Error fetching timetable: " + error.message);
            console.error("Fetch error:", error);
        }
    }

    // !displaying for individual faculty timetable
    function displayTimetable(timetableData) {
        const facultyTableContainer = document.getElementById("facultytable");
        facultyTableContainer.innerHTML = ""; // Clear previous table content

        // Create table element
        const table = document.createElement("table");

        // Create table header
        const headerRow = document.createElement("tr");

        // Days of the week for the first column
        const daysOfWeek = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"];

        // Create the first column header for the days of the week
        const dayHeader = document.createElement("th");
        dayHeader.textContent = "Day/Period";
        headerRow.appendChild(dayHeader);

        // Create period headers
        const periods = [
            "9:00-10:00",
            "10:00-11:00",
            "11:10-12:10",
            "12:55-1:55",
            "1:55-2:55",
            "2:55-3:45",
        ];
        periods.forEach((period) => {
            const th = document.createElement("th");
            th.textContent = period;
            headerRow.appendChild(th);
        });

        table.appendChild(headerRow);

        // Create a 5x6 empty grid (5 rows for days, 6 columns for periods)
        const timetableGrid = Array.from({ length: 5 }, () => Array(6).fill(""));
        console.log(timetableData);
        timetableData.forEach((row, rowIndex) => {
            row.forEach((cellValue, colIndex) => {
                timetableGrid[rowIndex][colIndex] = cellValue !== '.' ? cellValue : ""; // Replace '.' with an empty string
            });
        });

        // Populate the table with the timetable grid
        timetableGrid.forEach((row, rowIndex) => {
            const tr = document.createElement("tr");

            // Add the day (Monday to Friday) to the first column
            const dayCell = document.createElement("td");
            dayCell.textContent = daysOfWeek[rowIndex]; // Get the day based on row index
            tr.appendChild(dayCell);

            // Add the period slots (columns)
            row.forEach((cell) => {
                const td = document.createElement("td");
                td.textContent = cell || ""; // If no sectionId, leave the cell empty
                tr.appendChild(td);
            });

            table.appendChild(tr);
        });

        // Append the table to the facultytable div
        facultyTableContainer.appendChild(table);
        table.style.display = "table"; // Display the table
    }

    // Page-specific logic
    if (document.title === "Sending") {
        // Logic for the page where data is sent to the server
        const addSubjectButton = document.getElementById("addSubject");
        const sendDataButton = document.getElementById("sendData");
        const outputElement = document.getElementById("output");

        let sectionMap = new Map(); // Map<SecId, Map<FacultyId, [{ subjectId, isLab }]>>

        // Add subject to sectionMap
        addSubjectButton.addEventListener("click", () => {
            const sectionId = String(
                document.getElementById("sectionId").value.trim()
            );
            const facultyId = String(
                document.getElementById("facultyId").value,
                10
            );
            const subjectId = String(
                document.getElementById("subjectId").value.trim()
            );
            const isLab = document.getElementById("isLab").value === "true";

            if (!sectionId || !facultyId || !sectionId) {
                alert(
                    "Please enter valid inputs for Section ID, Faculty ID, and Subject ID."
                );
                return;
            }

            // Initialize sectionMap with a nested Map if it doesn't exist
            if (!sectionMap.has(sectionId)) {
                sectionMap.set(sectionId, new Map());
            }
            const facultyMap = sectionMap.get(sectionId);

            // Initialize facultyId map if it doesn't exist
            if (!facultyMap.has(facultyId)) {
                facultyMap.set(facultyId, []);
            }
            const subjectList = facultyMap.get(facultyId);

            // Check if the subject already exists
            let existingSubject = subjectList.find(
                (sub) => sub.subjectId === subjectId
            );

            if (!existingSubject) {
                existingSubject = { subjectId, isLab, facultyId: [facultyId] };
                subjectList.push(existingSubject);
            }

            // Prepare data in the desired format
            const result = Array.from(sectionMap.entries()).map(
                ([sectionId, facultyMap]) => ({
                    section: sectionId,
                    orderedSubjects: Array.from(facultyMap.entries()).map(
                        ([facultyId, subjects]) => ({
                            facultyId, // Faculty ID
                            subjects, // Subject list
                        })
                    ),
                })
            );
            console.log("result", result);
            // outputElement.textContent = JSON.stringify(result, null, 2);
            // console.log(result);

            // outputElement.textContent = JSON.stringify([...sectionMap], null, 2);
            console.log([...sectionMap]);
        });

        // Send data to the server
        sendDataButton.addEventListener("click", async () => {
            // Prepare data in the desired format
            const data = [];

            for (const [sectionId, facultyMap] of sectionMap.entries()) {
                let sectionEntry = data.find((entry) => entry.section === sectionId);

                if (!sectionEntry) {
                    sectionEntry = {
                        section: sectionId,
                        orderedSubjects: [],
                    };
                    data.push(sectionEntry);
                }

                const subjectMap = new Map(); // Map to group faculties by subjectId

                for (const [facultyId, facultySubjects] of facultyMap.entries()) {
                    const subjectsArray = Array.isArray(facultySubjects)
                        ? facultySubjects
                        : [facultySubjects];

                    subjectsArray.forEach((subject) => {
                        const subjectKey = subject.subjectId; // Use subjectId to group

                        if (!subjectMap.has(subjectKey)) {
                            subjectMap.set(subjectKey, {
                                facultyId: [],
                                isLab: subject.isLab,
                            });
                        }

                        subjectMap.get(subjectKey).facultyId.push(facultyId);
                    });
                }

                // Convert the subjectMap into an array and add it to orderedSubjects
                sectionEntry.orderedSubjects = Array.from(subjectMap.values());

                console.log("entries....", sectionEntry);
            }

            let storedData = localStorage.getItem("sectionMap");
            let existingSectionMap = new Map();

            if (storedData) {
                existingSectionMap = new Map(
                    JSON.parse(storedData).map(([sectionId, facultyObj]) => [
                        sectionId,
                        new Map(Object.entries(facultyObj)), // Convert inner Object back to Map
                    ])
                );
            }

            // Merge new sectionMap into existingSectionMap
            for (const [sectionId, facultyMap] of sectionMap.entries()) {
                if (!existingSectionMap.has(sectionId)) {
                    existingSectionMap.set(sectionId, facultyMap);
                } else {
                    const existingFacultyMap = existingSectionMap.get(sectionId);
                    for (const [facultyId, subjects] of facultyMap.entries()) {
                        if (!existingFacultyMap.has(facultyId)) {
                            existingFacultyMap.set(facultyId, subjects);
                        } else {
                            existingFacultyMap.get(facultyId).push(...subjects);
                        }
                    }
                }
            }

            // Store updated sectionMap in localStorage
            localStorage.setItem(
                "sectionMap",
                JSON.stringify(
                    Array.from(existingSectionMap.entries()).map(
                        ([sectionId, facultyMap]) => [
                            sectionId,
                            Object.fromEntries(facultyMap), // Convert inner Map to Object
                        ]
                    )
                )
            );

            console.log("in post", sectionMap);

            console.log("data is ", data, "type of", typeof data);
            sendDataToServer(data); // Call POST function
        });
    } else if (document.title === "Fetching") {
        // Logic for the page where data is fetched from the server
        console.log("i am in fetching");
        const fetchDataButton = document.getElementById("timetableForm");
        // GET Page
        const storedSectionMap = localStorage.getItem("sectionMap");

        if (storedSectionMap) {
            try {
                const parsedData = JSON.parse(storedSectionMap);
                console.log("Parsed sectionMap from localStorage:", parsedData);

                if (Array.isArray(parsedData)) {
                    sectionMap = new Map(
                        parsedData.map(([sectionId, facultyObj]) => [
                            sectionId,
                            new Map(Object.entries(facultyObj)), // Convert inner Object back to Map
                        ])
                    );
                    console.log("Successfully reconstructed Section Map:", sectionMap);
                } else {
                    console.error(
                        "Invalid data format in localStorage for sectionMap. Expected an array."
                    );
                    sectionMap = new Map(); // Reset to empty Map if invalid data is found
                }
            } catch (error) {
                console.error("Error parsing sectionMap from localStorage:", error);
                sectionMap = new Map(); // Reset in case of parsing failure
            }
        }

        fetchDataButton.addEventListener("submit", (event) => {
            event.preventDefault();
            fetchDataFromServer(sectionMap); // Now it will have the correct data
        });
    } else if (document.title === "Faculty Timetable") {
        document.getElementById("btn").addEventListener("click", (event) => {
            event.preventDefault();
            fetchTimetable();
        });
    }
});






import cors from "cors";
import express, { json } from "express";
import { Schema, connect, model } from "mongoose";

const PORT = 3000;

const app = express();
app.use(cors());
app.use(json());

// Section schema
const SectionSchema = new Schema({
    _id: String,
    timetable: [[String]], // 2D array of strings
    allocationMap: {
        type: Map,
        of: [[Number]], // Array of [row, col] positions
        default: () => new Map(), // Ensure default is a valid Map
    },
});

const Section = model("Section", SectionSchema);

const isSafe = (row, col, timetable, subject) => {
    if (timetable[row][col] !== ".") return false;

    let columnCount = 0;
    timetable.forEach((rowArr) => {
        if (rowArr[col] === subject) {
            columnCount++;
        }
    });
    if (columnCount >= 1) return false;

    if (timetable[row].includes(subject)) return false;

    return true;
};
const shuffleArray = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]]; // Swap elements
    }
};

const isRowEmptyInCols = (timetable, row, startCol, endCol) => {
    let val = true;
    for (let col = startCol; col <= endCol; col++) {
        if (timetable[row][col] !== ".") {
            val = false;
            break;
        }
    }
    return val;
};

// ✅ Faculty Conflict Check for Labs
const checkPrevLabs = (allSections, item, row, startCol, endCol, facultyIds) => {
    for (let allsec of allSections) {
        if (allsec._id !== item.section) {
            for (let [secSubjects, positions] of allsec.allocationMap.entries()) {
                let otherFacultyIds = secSubjects.split(",");

                const hasConflict = facultyIds.some((id) => otherFacultyIds.includes(id));
                if (!hasConflict) continue;

                for (let [r, c] of positions) {
                    if (r === row && c >= startCol && c <= endCol) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
};

const checkPrev = (allSections, item, row, col, subject) => {
    for (let allsec of allSections) {
        if (allsec._id !== item.section) {
            for (let [secSubjects, positions] of allsec.allocationMap.entries()) {
                if (secSubjects !== subject) continue;
                for (let [r, c] of positions) {
                    if (r === row && c === col) {
                        return false;
                    }
                }
            }
        }
    }
    return true;
};


// ✅ Lab Allocation with Even/Odd Section Handling
// const allocateLab = (sectionId, facultyIds, timetable, allocationMap, allSections, item, book, count_lab) => {
//     console.log(`🔹 Allocating lab for faculty: ${facultyIds} in section ${sectionId._id}`);

//     let allocated = false;
//     const sectionNumber = Number(sectionId._id);
//     const isEvenSection = sectionNumber % 2 === 0;
//     const morningLimit = isEvenSection ? 2 : 3;
//     const afternoonLimit = isEvenSection ? 3 : 2;

//     // ✅ Shuffle available rows to distribute labs across sections
//     let rows = [0, 1, 2, 3, 4];
//     shuffleArray(rows);

//     for (let row of rows) {
//         for (let col = 0; col <= timetable[row].length - 3; col++) {
//             // ✅ Check if faculty is already teaching in this slot in another section
//             let hasConflict = false;
//             //!checking as one 
//             for (let otherSection of allSections) {
//                 if (otherSection._id !== sectionId._id) {
//                     const otherAllocations = otherSection.allocationMap.get(facultyIds.toString()) || [];
//                     if (otherAllocations.some(([r, c]) => r === row && c >= col && c <= col + 2)) {
//                         hasConflict = true;
//                         break;
//                     }
//                 }
//             }
//             //!has error but check individual ie.,othersection
//             // for (let facultyId of facultyIds) { // ✅ Check each faculty separately
//             //     const otherAllocations = otherSection.allocationMap.get(facultyId.toString()) || [];
//             //     if (otherAllocations.some(([r, c]) => r === row && c >= col && c <= col + 2)) {
//             //         hasConflict = true;
//             //         console.log(`⚠️ Faculty ${facultyId} is already teaching at row ${row}, skipping.`);
//             //         break; // Stop checking further if conflict is found
//             //     }
//             // }
//             //!try
//             // if (!Array.isArray(allSections) || allSections.length === 0) {
//             //     console.error("⚠️ allSections is empty or not an array.");
//             // } else {
//             //     for (let otherSection of allSections) {
//             //         if (!otherSection || !otherSection.allocationMap) continue; // Skip undefined entries

//             //         if (otherSection._id !== sectionId._id) {
//             //             for (let faculty of facultyIds) { // ✅ Check each faculty individually
//             //                 const otherAllocations = otherSection.allocationMap.get(faculty.toString()) || [];
//             //                 if (otherAllocations.some(([r, c]) => r === row && c >= col && c <= col + 2)) {
//             //                     hasConflict = true;
//             //                     console.log(`⚠️ Faculty ${faculty} is already teaching at row ${row}, skipping.`);
//             //                     break;
//             //                 }
//             //             }
//             //         }
//             //         if (hasConflict) break;
//             //     }
//             // }

//             if (hasConflict) {
//                 console.log(`⚠️ Faculty ${facultyIds} is already teaching at row ${row}, skipping.`);
//                 continue;
//             }

//             if (
//                 isRowEmptyInCols(timetable, row, col, col + 2) && // Ensure row is empty
//                 book[row] === 0 // Row is not occupied
//             ) {
//                 console.log(`✅ Successfully allocated lab for ${facultyIds} in row ${row}, cols ${col}-${col + 2}`);

//                 for (let i = 0; i < 3; i++) {
//                     timetable[row][col + i] = facultyIds.join(",");
//                 }

//                 // ✅ Append allocation instead of overwriting
//                 if (!allocationMap.has(facultyIds.toString())) {
//                     allocationMap.set(facultyIds.toString(), []);
//                 }
//                 allocationMap.get(facultyIds.toString()).push(
//                     [row, col],
//                     [row, col + 1],
//                     [row, col + 2]
//                 );

//                 // ✅ Update morning/afternoon count
//                 if (col === 0 && count_lab[0] < morningLimit) count_lab[0]++;
//                 else if (col === 3 && count_lab[1] < afternoonLimit) count_lab[1]++;

//                 // ✅ Mark row as occupied
//                 book[row] = -1;
//                 allocated = true;
//                 break;
//             }
//         }
//         if (allocated) break;
//     }

//     // ❌ If allocation failed, try reallocation
//     if (!allocated) {
//         console.log(`⚠️ Lab allocation failed for faculty: ${facultyIds}. Attempting reallocation.`);
//         reallocateLab(sectionId, facultyIds, timetable, allocationMap, allSections, item);
//     }

//     sectionId.timetable = timetable;
//     sectionId.allocationMap = allocationMap;
// };


const allocateLab = (sectionId, facultyIds, timetable, allocationMap, allSections, item, book, count_lab) => {
    console.log(`🔹 Allocating lab for faculty: ${facultyIds} in section ${sectionId._id}`);

    let allocated = false;
    const sectionNumber = Number(sectionId._id);
    const isEvenSection = sectionNumber % 2 === 0;

    const morningLimit = isEvenSection ? 3 : 2;
    const afternoonLimit = isEvenSection ? 2 : 3;

    const labSlots = [
        { startCol: 0, limitType: "morning" },
        { startCol: 3, limitType: "afternoon" },
    ];

    let rows = [0, 1, 2, 3, 4];
    shuffleArray(rows);

    for (let { startCol, limitType } of labSlots) {
        const limitReached = (limitType === "morning" && count_lab[0] >= morningLimit) ||
            (limitType === "afternoon" && count_lab[1] >= afternoonLimit);

        if (limitReached) continue;

        for (let row of rows) {
            const endCol = startCol + 2;

            // Conflict check
            let hasConflict = false;
            for (let otherSection of allSections) {
                if (otherSection._id !== sectionId._id) {
                    const otherAllocations = otherSection.allocationMap.get(facultyIds.toString()) || [];
                    if (otherAllocations.some(([r, c]) => r === row && c >= startCol && c <= endCol)) {
                        hasConflict = true;
                        break;
                    }
                }
            }

            if (hasConflict) {
                console.log(`⚠️ Faculty ${facultyIds} is already teaching at row ${row}, skipping.`);
                continue;
            }

            if (
                isRowEmptyInCols(timetable, row, startCol, endCol) &&
                book[row] === 0
            ) {
                console.log(`✅ Allocated lab in row ${row}, cols ${startCol}-${endCol}`);

                for (let i = 0; i < 3; i++) {
                    timetable[row][startCol + i] = facultyIds.join(",");
                }

                if (!allocationMap.has(facultyIds.toString())) {
                    allocationMap.set(facultyIds.toString(), []);
                }
                allocationMap.get(facultyIds.toString()).push(
                    [row, startCol],
                    [row, startCol + 1],
                    [row, startCol + 2]
                );

                if (limitType === "morning") count_lab[0]++;
                else count_lab[1]++;

                book[row] = -1;
                allocated = true;
                break;
            }
        }

        if (allocated) break;
    }

    if (!allocated) {
        console.log(`⚠️ Lab allocation failed for faculty: ${facultyIds}. Attempting reallocation.`);
        reallocateLab(sectionId, facultyIds, timetable, allocationMap, allSections, item);
    }

    sectionId.timetable = timetable;
    sectionId.allocationMap = allocationMap;
};




// ✅ Lab Reallocation
// const reallocatelab = (sectionId, facultyIds, timetable, allocationMap, allSections, item) => {
//     console.log(`🔄 Attempting to reallocate lab for faculty: ${facultyIds}`);

//     let oldPositions = allocationMap.get(facultyIds.toString());
//     if (!oldPositions || oldPositions.length === 0) {
//         console.log(`⚠️ No existing allocation found for ${facultyIds}. Skipping reallocation.`);
//         return false;
//     }

//     let [oldRow, startCol] = oldPositions[0];

//     for (let col = startCol; col < startCol + 3; col++) {
//         timetable[oldRow][col] = ".";
//     }
//     allocationMap.delete(facultyIds.toString());

//     allocateLab(sectionId, facultyIds, timetable, allocationMap, allSections, item, book, count_lab);
//     return true;
// };


const reallocate = async (
    isLab,
    allocationCount,
    allocationMap,
    currsubject,
    sectionId,
    timetable,
    allSections,
    item
) => {
    const keysArray = Array.from(allocationMap.keys());
    let idx = 2;

    while (idx <= keysArray.length) {
        const lastKey = keysArray[keysArray.length - idx];
        console.log("I am in reallocate method. Current Key:", lastKey);

        if (isLab) {
            console.log(`Skipping reallocation for lab: ${lastKey}`);
            idx++;
            continue;
        }

        const values = allocationMap.get(lastKey);
        console.log("Values are:", values);

        if (!values || values.length === 0) {
            console.error("No positions found for lastKey:", lastKey);
            idx++;
            continue;
        }

        console.log("Current subject:", currsubject);

        let allocated = false;
        for (let row = 0; row < timetable.length && !allocated; row++) {
            for (let col = 0; col < timetable[row].length && !allocated; col++) {
                if (timetable[row][col] === ".") {
                    for (let i = 0; i < values.length && !allocated; i++) {
                        const [r, c] = values[i];
                        console.log("r:", r, "c:", c, "row:", row, "col:", col);

                        timetable[r][c] = ".";
                        if (
                            isSafe(r, c, timetable, currsubject) &&
                            checkPrev(allSections, item, r, c, currsubject) &&
                            isSafe(row, col, timetable, lastKey) &&
                            checkPrev(allSections, item, row, col, lastKey)
                        ) {
                            console.log("In isSafe for subject:", lastKey);

                            timetable[r][c] = currsubject;
                            timetable[row][col] = lastKey;

                            allocationCount++;
                            allocationMap.set(currsubject, [
                                ...(allocationMap.get(currsubject) || []),
                                [r, c],
                            ]);
                            allocationMap.set(
                                lastKey,
                                [
                                    ...(allocationMap.get(lastKey) || []),
                                    [row, col],
                                ].filter(([vr, vc]) => !(vr === r && vc === c))
                            );

                            console.log(`Swapped: (${r}, ${c}) with (${row}, ${col})`);

                            sectionId.timetable = timetable;
                            sectionId.allocationMap = allocationMap;
                            break;
                        } else {
                            timetable[r][c] = lastKey;
                        }
                    }
                    idx++;
                }
                if (allocationCount === 3) break;
            }
        }

        if (allocationCount === 3) break;
    }
};


const allocateSec = async (
    sectionId,
    faculties,
    isLab,
    allocationMap,
    timetable,
    book,
    count_lab,
    allSections,
    item
) => {

    console.log(`type....${typeof (faculties)}`)
    //console.log(`Starting allocation for faculties: ${faculties.join(', ')}, isLab: ${isLab}`);
    if (isLab) {
        console.log(`🔷 Lab Allocation for faculties: ${faculties}`);
        allocateLab(sectionId, faculties, timetable, allocationMap, allSections, item, book, count_lab);
    } else {
        console.log(`Allocating non - lab subject: ${faculties}`);
        let allocationCount = 0;
        const subject = faculties.toString();

        for (let row = 0; row < timetable.length; row++) {
            for (let col = 0; col < timetable[row].length; col++) {
                if (
                    isSafe(row, col, timetable, subject) &&
                    checkPrev(allSections, item, row, col, subject)
                ) {
                    timetable[row][col] = subject;
                    allocationCount++;
                    console.log(
                        `Allocated subject: ${subject} at row: ${row}, col: ${col}`
                    );

                    if (!allocationMap.has(subject)) allocationMap.set(subject, []);
                    allocationMap.get(subject).push([row, col]);

                    if (allocationCount === 3) break;
                }
            }

            if (allocationCount === 3) {
                break;
            }
        }

        sectionId.timetable = timetable;
        sectionId.allocationMap = allocationMap;

        if (allocationCount < 3) {
            console.log(
                `Subject: ${subject} allocation incomplete.Attempting reallocation.`
            );
            await reallocate(
                isLab,
                allocationCount,
                allocationMap,
                subject,
                sectionId,
                timetable,
                allSections,
                item
            );
            sectionId.timetable = timetable;
            sectionId.allocationMap = allocationMap;
        }

        console.log(`Allocation completed for non - lab subject: ${subject}`);
    }

    return { timetable, allocationMap };
};

app.post("/allocate", async (req, res) => {
    console.log("Received allocation request");
    const data = req.body;
    console.log("data is ", data)
    try {
        for (const item of data) {
            console.log(`Processing section: ${item.section}${typeof (item.section)}`);
            let sec = await Section.findById(item.section);
            if (!sec) {
                console.log(`Section: ${item.section} not found. Initializing.`);
                const initialTimetable = Array.from({ length: 5 }, () => Array(6).fill("."));
                sec = new Section({
                    _id: item.section,
                    timetable: initialTimetable,
                });
                await sec.save();
            }

            const book = new Array(5).fill(0);
            const count_lab = new Array(2).fill(0);
            const timetable = sec.timetable;
            let allocationMap = sec.allocationMap || new Map();
            const allSections = await Section.find();

            const labSubjects = item.orderedSubjects.filter((sub) => sub.isLab);
            const nonLabSubjects = item.orderedSubjects.filter((sub) => !sub.isLab);
            //console.log("type..............", typeof (facultyId))
            console.log("lab facultyIds")
            for (const { facultyId, isLab } of labSubjects) {
                console.log("..................", facultyId, "....................")
            }
            console.log("nonlab facultyIds")
            for (const { facultyId, isLab } of nonLabSubjects) {
                console.log("..................", facultyId, "....................")
            }
            for (const { facultyId, isLab } of labSubjects) {
                await allocateSec(
                    sec,
                    facultyId,
                    isLab,
                    allocationMap,
                    timetable,
                    book,
                    count_lab,
                    allSections,
                    item
                );
            }

            for (const { facultyId, isLab } of nonLabSubjects) {
                await allocateSec(
                    sec,
                    facultyId,
                    isLab,
                    allocationMap,
                    timetable,
                    book,
                    count_lab,
                    allSections,
                    item
                );
            }

            await sec.save();
            console.log("Allocation completed for section:", item.section);
            console.table(timetable);
            console.log("allocation map...........", allocationMap)

        }
        const allSections = await Section.find({}, { _id: 1, timetable: 1 });
        const timetable = allSections.timetable;  // Access the timetable array of objects
        console.log("timetable", timetable);
        res.status(200).json({ message: "Allocation successful" });
        console.log("Allocation request processed successfully");
    } catch (err) {
        console.error("Error during allocation:", err);
        res.status(500).json({
            message: "Error occurred during allocation",
            error: err.message,
        });
    }
});


//! get the section timetable display
app.get("/tt/:sectionId", async (req, res) => {
    const { sectionId } = req.params;
    try {

        const section = await Section.findById(sectionId);
        if (!section) {
            return res.status(404).json({ message: "Section not found" });
        }
        res.status(200).json({ timetable: section.timetable, allocationMap: section.allocationMap });
        //res.status(200).json({ timetable: section.timetable });
    } catch (err) {
        console.error("Error fetching timetable:", err);
        res.status(500).json({ message: "Error occurred while fetching timetable", error: err.message });
    }
});


//!  get the individual faculty timetable
app.get("/ft/:facultyId", async (req, res) => {
    const { facultyId } = req.params;
    console.log("📌 Received facultyId request:", facultyId);
    try {
        // Create a blank faculty timetable
        const facultyTimetable = Array(5).fill(null).map(() => Array(6).fill("."));

        // Fetch all sections
        const sections = await Section.find();

        sections.forEach((section) => {
            const allocationMap = section.allocationMap;

            console.log("🗺️ Checking allocationMap for faculty:", facultyId, "=>", allocationMap);

            // Iterate over all stored faculty allocations
            allocationMap.forEach((positions, key) => {
                if (key.includes(facultyId)) {  // ✅ Check if facultyId exists in a multi-faculty key
                    console.log(`✅ Faculty ${facultyId} found in ${key}, positions:`, positions);
                    positions.forEach(([row, col]) => {
                        facultyTimetable[row][col] = section._id; // ✅ Store section ID in timetable
                    });
                }
            });
        });

        console.log("📋 Final faculty timetable:", facultyTimetable);
        res.json({ facultyTimetable });

    } catch (error) {
        console.error("❌ Error fetching faculty timetable:", error);
        res.status(500).json({ message: "Internal Server Error", error: error.message });
    }
});




// MongoDB connection and server start
connect("mongodb://localhost:27017/school", {
    useNewUrlParser: true,
    useUnifiedTopology: true,
})
    .then(() => {
        console.log("Connected to MongoDB");
        app.listen(3000, () => {
            console.log("Server is running on port 3000");
        });
    })
    .catch((error) => {
        console.error("MongoDB connection error:");
    });